{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 /**\par
 *Submitted for verification at BscScan.com on 2021-11-21\par
*/\par
\par
// Dependency file: @openzeppelin/contracts/token/ERC20/IERC20.sol\par
\par
// SPDX-License-Identifier: MIT\par
\par
// pragma solidity ^0.8.0;\par
\par
/**\par
 * @dev Interface of the ERC20 standard as defined in the EIP.\par
 */\par
interface IERC20 \{\par
    /**\par
     * @dev Returns the amount of tokens in existence.\par
     */\par
    function totalSupply() external view returns (uint256);\par
\par
    /**\par
     * @dev Returns the amount of tokens owned by `account`.\par
     */\par
    function balanceOf(address account) external view returns (uint256);\par
\par
    /**\par
     * @dev Moves `amount` tokens from the caller's account to `recipient`.\par
     *\par
     * Returns a boolean value indicating whether the operation succeeded.\par
     *\par
     * Emits a \{Transfer\} event.\par
     */\par
    function transfer(address recipient, uint256 amount) external returns (bool);\par
\par
    /**\par
     * @dev Returns the remaining number of tokens that `spender` will be\par
     * allowed to spend on behalf of `owner` through \{transferFrom\}. This is\par
     * zero by default.\par
     *\par
     * This value changes when \{approve\} or \{transferFrom\} are called.\par
     */\par
    function allowance(address owner, address spender) external view returns (uint256);\par
\par
    /**\par
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\par
     *\par
     * Returns a boolean value indicating whether the operation succeeded.\par
     *\par
     * IMPORTANT: Beware that changing an allowance with this method brings the risk\par
     * that someone may use both the old and the new allowance by unfortunate\par
     * transaction ordering. One possible solution to mitigate this race\par
     * condition is to first reduce the spender's allowance to 0 and set the\par
     * desired value afterwards:\par
     * {{\field{\*\fldinst{HYPERLINK https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 }}{\fldrslt{https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\ul0\cf0}}}}\f0\fs22\par
     *\par
     * Emits an \{Approval\} event.\par
     */\par
    function approve(address spender, uint256 amount) external returns (bool);\par
\par
    /**\par
     * @dev Moves `amount` tokens from `sender` to `recipient` using the\par
     * allowance mechanism. `amount` is then deducted from the caller's\par
     * allowance.\par
     *\par
     * Returns a boolean value indicating whether the operation succeeded.\par
     *\par
     * Emits a \{Transfer\} event.\par
     */\par
    function transferFrom(\par
        address sender,\par
        address recipient,\par
        uint256 amount\par
    ) external returns (bool);\par
\par
    /**\par
     * @dev Emitted when `value` tokens are moved from one account (`from`) to\par
     * another (`to`).\par
     *\par
     * Note that `value` may be zero.\par
     */\par
    event Transfer(address indexed from, address indexed to, uint256 value);\par
\par
    /**\par
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\par
     * a call to \{approve\}. `value` is the new allowance.\par
     */\par
    event Approval(address indexed owner, address indexed spender, uint256 value);\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
// import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\par
\par
/**\par
 * @dev Interface for the optional metadata functions from the ERC20 standard.\par
 *\par
 * _Available since v4.1._\par
 */\par
interface IERC20Metadata is IERC20 \{\par
    /**\par
     * @dev Returns the name of the token.\par
     */\par
    function name() external view returns (string memory);\par
\par
    /**\par
     * @dev Returns the symbol of the token.\par
     */\par
    function symbol() external view returns (string memory);\par
\par
    /**\par
     * @dev Returns the decimals places of the token.\par
     */\par
    function decimals() external view returns (uint8);\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts/utils/Context.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
/**\par
 * @dev Provides information about the current execution context, including the\par
 * sender of the transaction and its data. While these are generally available\par
 * via msg.sender and msg.data, they should not be accessed in such a direct\par
 * manner, since when dealing with meta-transactions the account sending and\par
 * paying for execution may not be the actual sender (as far as an application\par
 * is concerned).\par
 *\par
 * This contract is only required for intermediate, library-like contracts.\par
 */\par
abstract contract Context \{\par
    function _msgSender() internal view virtual returns (address) \{\par
        return msg.sender;\par
    \}\par
\par
    function _msgData() internal view virtual returns (bytes calldata) \{\par
        return msg.data;\par
    \}\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts/token/ERC20/ERC20.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
// import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\par
// import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";\par
// import "@openzeppelin/contracts/utils/Context.sol";\par
\par
/**\par
 * @dev Implementation of the \{IERC20\} interface.\par
 *\par
 * This implementation is agnostic to the way tokens are created. This means\par
 * that a supply mechanism has to be added in a derived contract using \{_mint\}.\par
 * For a generic mechanism see \{ERC20PresetMinterPauser\}.\par
 *\par
 * TIP: For a detailed writeup see our guide\par
 * {{\field{\*\fldinst{HYPERLINK https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How }}{\fldrslt{https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\ul0\cf0}}}}\f0\fs22\par
 * to implement supply mechanisms].\par
 *\par
 * We have followed general OpenZeppelin Contracts guidelines: functions revert\par
 * instead returning `false` on failure. This behavior is nonetheless\par
 * conventional and does not conflict with the expectations of ERC20\par
 * applications.\par
 *\par
 * Additionally, an \{Approval\} event is emitted on calls to \{transferFrom\}.\par
 * This allows applications to reconstruct the allowance for all accounts just\par
 * by listening to said events. Other implementations of the EIP may not emit\par
 * these events, as it isn't required by the specification.\par
 *\par
 * Finally, the non-standard \{decreaseAllowance\} and \{increaseAllowance\}\par
 * functions have been added to mitigate the well-known issues around setting\par
 * allowances. See \{IERC20-approve\}.\par
 */\par
contract ERC20 is Context, IERC20, IERC20Metadata \{\par
    mapping(address => uint256) private _balances;\par
\par
    mapping(address => mapping(address => uint256)) private _allowances;\par
\par
    uint256 private _totalSupply;\par
\par
    string private _name;\par
    string private _symbol;\par
\par
    /**\par
     * @dev Sets the values for \{name\} and \{symbol\}.\par
     *\par
     * The default value of \{decimals\} is 18. To select a different value for\par
     * \{decimals\} you should overload it.\par
     *\par
     * All two of these values are immutable: they can only be set once during\par
     * construction.\par
     */\par
    constructor(string memory name_, string memory symbol_) \{\par
        _name = name_;\par
        _symbol = symbol_;\par
    \}\par
\par
    /**\par
     * @dev Returns the name of the token.\par
     */\par
    function name() public view virtual override returns (string memory) \{\par
        return _name;\par
    \}\par
\par
    /**\par
     * @dev Returns the symbol of the token, usually a shorter version of the\par
     * name.\par
     */\par
    function symbol() public view virtual override returns (string memory) \{\par
        return _symbol;\par
    \}\par
\par
    /**\par
     * @dev Returns the number of decimals used to get its user representation.\par
     * For example, if `decimals` equals `2`, a balance of `505` tokens should\par
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\par
     *\par
     * Tokens usually opt for a value of 18, imitating the relationship between\par
     * Ether and Wei. This is the value \{ERC20\} uses, unless this function is\par
     * overridden;\par
     *\par
     * NOTE: This information is only used for _display_ purposes: it in\par
     * no way affects any of the arithmetic of the contract, including\par
     * \{IERC20-balanceOf\} and \{IERC20-transfer\}.\par
     */\par
    function decimals() public view virtual override returns (uint8) \{\par
        return 18;\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-totalSupply\}.\par
     */\par
    function totalSupply() public view virtual override returns (uint256) \{\par
        return _totalSupply;\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-balanceOf\}.\par
     */\par
    function balanceOf(address account) public view virtual override returns (uint256) \{\par
        return _balances[account];\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-transfer\}.\par
     *\par
     * Requirements:\par
     *\par
     * - `recipient` cannot be the zero address.\par
     * - the caller must have a balance of at least `amount`.\par
     */\par
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) \{\par
        _transfer(_msgSender(), recipient, amount);\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-allowance\}.\par
     */\par
    function allowance(address owner, address spender) public view virtual override returns (uint256) \{\par
        return _allowances[owner][spender];\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-approve\}.\par
     *\par
     * Requirements:\par
     *\par
     * - `spender` cannot be the zero address.\par
     */\par
    function approve(address spender, uint256 amount) public virtual override returns (bool) \{\par
        _approve(_msgSender(), spender, amount);\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-transferFrom\}.\par
     *\par
     * Emits an \{Approval\} event indicating the updated allowance. This is not\par
     * required by the EIP. See the note at the beginning of \{ERC20\}.\par
     *\par
     * Requirements:\par
     *\par
     * - `sender` and `recipient` cannot be the zero address.\par
     * - `sender` must have a balance of at least `amount`.\par
     * - the caller must have allowance for ``sender``'s tokens of at least\par
     * `amount`.\par
     */\par
    function transferFrom(\par
        address sender,\par
        address recipient,\par
        uint256 amount\par
    ) public virtual override returns (bool) \{\par
        _transfer(sender, recipient, amount);\par
\par
        uint256 currentAllowance = _allowances[sender][_msgSender()];\par
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\par
        unchecked \{\par
            _approve(sender, _msgSender(), currentAllowance - amount);\par
        \}\par
\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev Atomically increases the allowance granted to `spender` by the caller.\par
     *\par
     * This is an alternative to \{approve\} that can be used as a mitigation for\par
     * problems described in \{IERC20-approve\}.\par
     *\par
     * Emits an \{Approval\} event indicating the updated allowance.\par
     *\par
     * Requirements:\par
     *\par
     * - `spender` cannot be the zero address.\par
     */\par
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) \{\par
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev Atomically decreases the allowance granted to `spender` by the caller.\par
     *\par
     * This is an alternative to \{approve\} that can be used as a mitigation for\par
     * problems described in \{IERC20-approve\}.\par
     *\par
     * Emits an \{Approval\} event indicating the updated allowance.\par
     *\par
     * Requirements:\par
     *\par
     * - `spender` cannot be the zero address.\par
     * - `spender` must have allowance for the caller of at least\par
     * `subtractedValue`.\par
     */\par
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) \{\par
        uint256 currentAllowance = _allowances[_msgSender()][spender];\par
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\par
        unchecked \{\par
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\par
        \}\par
\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev Moves `amount` of tokens from `sender` to `recipient`.\par
     *\par
     * This internal function is equivalent to \{transfer\}, and can be used to\par
     * e.g. implement automatic token fees, slashing mechanisms, etc.\par
     *\par
     * Emits a \{Transfer\} event.\par
     *\par
     * Requirements:\par
     *\par
     * - `sender` cannot be the zero address.\par
     * - `recipient` cannot be the zero address.\par
     * - `sender` must have a balance of at least `amount`.\par
     */\par
    function _transfer(\par
        address sender,\par
        address recipient,\par
        uint256 amount\par
    ) internal virtual \{\par
        require(sender != address(0), "ERC20: transfer from the zero address");\par
        require(recipient != address(0), "ERC20: transfer to the zero address");\par
\par
        _beforeTokenTransfer(sender, recipient, amount);\par
\par
        uint256 senderBalance = _balances[sender];\par
        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\par
        unchecked \{\par
            _balances[sender] = senderBalance - amount;\par
        \}\par
        _balances[recipient] += amount;\par
\par
        emit Transfer(sender, recipient, amount);\par
\par
        _afterTokenTransfer(sender, recipient, amount);\par
    \}\par
\par
    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\par
     * the total supply.\par
     *\par
     * Emits a \{Transfer\} event with `from` set to the zero address.\par
     *\par
     * Requirements:\par
     *\par
     * - `account` cannot be the zero address.\par
     */\par
    function _mint(address account, uint256 amount) internal virtual \{\par
        require(account != address(0), "ERC20: mint to the zero address");\par
\par
        _beforeTokenTransfer(address(0), account, amount);\par
\par
        _totalSupply += amount;\par
        _balances[account] += amount;\par
        emit Transfer(address(0), account, amount);\par
\par
        _afterTokenTransfer(address(0), account, amount);\par
    \}\par
\par
    /**\par
     * @dev Destroys `amount` tokens from `account`, reducing the\par
     * total supply.\par
     *\par
     * Emits a \{Transfer\} event with `to` set to the zero address.\par
     *\par
     * Requirements:\par
     *\par
     * - `account` cannot be the zero address.\par
     * - `account` must have at least `amount` tokens.\par
     */\par
    function _burn(address account, uint256 amount) internal virtual \{\par
        require(account != address(0), "ERC20: burn from the zero address");\par
\par
        _beforeTokenTransfer(account, address(0), amount);\par
\par
        uint256 accountBalance = _balances[account];\par
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\par
        unchecked \{\par
            _balances[account] = accountBalance - amount;\par
        \}\par
        _totalSupply -= amount;\par
\par
        emit Transfer(account, address(0), amount);\par
\par
        _afterTokenTransfer(account, address(0), amount);\par
    \}\par
\par
    /**\par
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\par
     *\par
     * This internal function is equivalent to `approve`, and can be used to\par
     * e.g. set automatic allowances for certain subsystems, etc.\par
     *\par
     * Emits an \{Approval\} event.\par
     *\par
     * Requirements:\par
     *\par
     * - `owner` cannot be the zero address.\par
     * - `spender` cannot be the zero address.\par
     */\par
    function _approve(\par
        address owner,\par
        address spender,\par
        uint256 amount\par
    ) internal virtual \{\par
        require(owner != address(0), "ERC20: approve from the zero address");\par
        require(spender != address(0), "ERC20: approve to the zero address");\par
\par
        _allowances[owner][spender] = amount;\par
        emit Approval(owner, spender, amount);\par
    \}\par
\par
    /**\par
     * @dev Hook that is called before any transfer of tokens. This includes\par
     * minting and burning.\par
     *\par
     * Calling conditions:\par
     *\par
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\par
     * will be transferred to `to`.\par
     * - when `from` is zero, `amount` tokens will be minted for `to`.\par
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\par
     * - `from` and `to` are never both zero.\par
     *\par
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\par
     */\par
    function _beforeTokenTransfer(\par
        address from,\par
        address to,\par
        uint256 amount\par
    ) internal virtual \{\}\par
\par
    /**\par
     * @dev Hook that is called after any transfer of tokens. This includes\par
     * minting and burning.\par
     *\par
     * Calling conditions:\par
     *\par
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\par
     * has been transferred to `to`.\par
     * - when `from` is zero, `amount` tokens have been minted for `to`.\par
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\par
     * - `from` and `to` are never both zero.\par
     *\par
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\par
     */\par
    function _afterTokenTransfer(\par
        address from,\par
        address to,\par
        uint256 amount\par
    ) internal virtual \{\}\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts/access/Ownable.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
// import "@openzeppelin/contracts/utils/Context.sol";\par
\par
/**\par
 * @dev Contract module which provides a basic access control mechanism, where\par
 * there is an account (an owner) that can be granted exclusive access to\par
 * specific functions.\par
 *\par
 * By default, the owner account will be the one that deploys the contract. This\par
 * can later be changed with \{transferOwnership\}.\par
 *\par
 * This module is used through inheritance. It will make available the modifier\par
 * `onlyOwner`, which can be applied to your functions to restrict their use to\par
 * the owner.\par
 */\par
abstract contract Ownable is Context \{\par
    address private _owner;\par
\par
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\par
\par
    /**\par
     * @dev Initializes the contract setting the deployer as the initial owner.\par
     */\par
    constructor() \{\par
        _setOwner(_msgSender());\par
    \}\par
\par
    /**\par
     * @dev Returns the address of the current owner.\par
     */\par
    function owner() public view virtual returns (address) \{\par
        return _owner;\par
    \}\par
\par
    /**\par
     * @dev Throws if called by any account other than the owner.\par
     */\par
    modifier onlyOwner() \{\par
        require(owner() == _msgSender(), "Ownable: caller is not the owner");\par
        _;\par
    \}\par
\par
    /**\par
     * @dev Leaves the contract without owner. It will not be possible to call\par
     * `onlyOwner` functions anymore. Can only be called by the current owner.\par
     *\par
     * NOTE: Renouncing ownership will leave the contract without an owner,\par
     * thereby removing any functionality that is only available to the owner.\par
     */\par
    function renounceOwnership() public virtual onlyOwner \{\par
        _setOwner(address(0));\par
    \}\par
\par
    /**\par
     * @dev Transfers ownership of the contract to a new account (`newOwner`).\par
     * Can only be called by the current owner.\par
     */\par
    function transferOwnership(address newOwner) public virtual onlyOwner \{\par
        require(newOwner != address(0), "Ownable: new owner is the zero address");\par
        _setOwner(newOwner);\par
    \}\par
\par
    function _setOwner(address newOwner) private \{\par
        address oldOwner = _owner;\par
        _owner = newOwner;\par
        emit OwnershipTransferred(oldOwner, newOwner);\par
    \}\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts/utils/math/SafeMath.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
// CAUTION\par
// This version of SafeMath should only be used with Solidity 0.8 or later,\par
// because it relies on the compiler's built in overflow checks.\par
\par
/**\par
 * @dev Wrappers over Solidity's arithmetic operations.\par
 *\par
 * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\par
 * now has built in overflow checking.\par
 */\par
library SafeMath \{\par
    /**\par
     * @dev Returns the addition of two unsigned integers, with an overflow flag.\par
     *\par
     * _Available since v3.4._\par
     */\par
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) \{\par
        unchecked \{\par
            uint256 c = a + b;\par
            if (c < a) return (false, 0);\par
            return (true, c);\par
        \}\par
    \}\par
\par
    /**\par
     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\par
     *\par
     * _Available since v3.4._\par
     */\par
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) \{\par
        unchecked \{\par
            if (b > a) return (false, 0);\par
            return (true, a - b);\par
        \}\par
    \}\par
\par
    /**\par
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\par
     *\par
     * _Available since v3.4._\par
     */\par
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) \{\par
        unchecked \{\par
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\par
            // benefit is lost if 'b' is also tested.\par
            // See: {{\field{\*\fldinst{HYPERLINK https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 }}{\fldrslt{https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\ul0\cf0}}}}\f0\fs22\par
            if (a == 0) return (true, 0);\par
            uint256 c = a * b;\par
            if (c / a != b) return (false, 0);\par
            return (true, c);\par
        \}\par
    \}\par
\par
    /**\par
     * @dev Returns the division of two unsigned integers, with a division by zero flag.\par
     *\par
     * _Available since v3.4._\par
     */\par
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) \{\par
        unchecked \{\par
            if (b == 0) return (false, 0);\par
            return (true, a / b);\par
        \}\par
    \}\par
\par
    /**\par
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\par
     *\par
     * _Available since v3.4._\par
     */\par
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) \{\par
        unchecked \{\par
            if (b == 0) return (false, 0);\par
            return (true, a % b);\par
        \}\par
    \}\par
\par
    /**\par
     * @dev Returns the addition of two unsigned integers, reverting on\par
     * overflow.\par
     *\par
     * Counterpart to Solidity's `+` operator.\par
     *\par
     * Requirements:\par
     *\par
     * - Addition cannot overflow.\par
     */\par
    function add(uint256 a, uint256 b) internal pure returns (uint256) \{\par
        return a + b;\par
    \}\par
\par
    /**\par
     * @dev Returns the subtraction of two unsigned integers, reverting on\par
     * overflow (when the result is negative).\par
     *\par
     * Counterpart to Solidity's `-` operator.\par
     *\par
     * Requirements:\par
     *\par
     * - Subtraction cannot overflow.\par
     */\par
    function sub(uint256 a, uint256 b) internal pure returns (uint256) \{\par
        return a - b;\par
    \}\par
\par
    /**\par
     * @dev Returns the multiplication of two unsigned integers, reverting on\par
     * overflow.\par
     *\par
     * Counterpart to Solidity's `*` operator.\par
     *\par
     * Requirements:\par
     *\par
     * - Multiplication cannot overflow.\par
     */\par
    function mul(uint256 a, uint256 b) internal pure returns (uint256) \{\par
        return a * b;\par
    \}\par
\par
    /**\par
     * @dev Returns the integer division of two unsigned integers, reverting on\par
     * division by zero. The result is rounded towards zero.\par
     *\par
     * Counterpart to Solidity's `/` operator.\par
     *\par
     * Requirements:\par
     *\par
     * - The divisor cannot be zero.\par
     */\par
    function div(uint256 a, uint256 b) internal pure returns (uint256) \{\par
        return a / b;\par
    \}\par
\par
    /**\par
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\par
     * reverting when dividing by zero.\par
     *\par
     * Counterpart to Solidity's `%` operator. This function uses a `revert`\par
     * opcode (which leaves remaining gas untouched) while Solidity uses an\par
     * invalid opcode to revert (consuming all remaining gas).\par
     *\par
     * Requirements:\par
     *\par
     * - The divisor cannot be zero.\par
     */\par
    function mod(uint256 a, uint256 b) internal pure returns (uint256) \{\par
        return a % b;\par
    \}\par
\par
    /**\par
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\par
     * overflow (when the result is negative).\par
     *\par
     * CAUTION: This function is deprecated because it requires allocating memory for the error\par
     * message unnecessarily. For custom revert reasons use \{trySub\}.\par
     *\par
     * Counterpart to Solidity's `-` operator.\par
     *\par
     * Requirements:\par
     *\par
     * - Subtraction cannot overflow.\par
     */\par
    function sub(\par
        uint256 a,\par
        uint256 b,\par
        string memory errorMessage\par
    ) internal pure returns (uint256) \{\par
        unchecked \{\par
            require(b <= a, errorMessage);\par
            return a - b;\par
        \}\par
    \}\par
\par
    /**\par
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\par
     * division by zero. The result is rounded towards zero.\par
     *\par
     * Counterpart to Solidity's `/` operator. Note: this function uses a\par
     * `revert` opcode (which leaves remaining gas untouched) while Solidity\par
     * uses an invalid opcode to revert (consuming all remaining gas).\par
     *\par
     * Requirements:\par
     *\par
     * - The divisor cannot be zero.\par
     */\par
    function div(\par
        uint256 a,\par
        uint256 b,\par
        string memory errorMessage\par
    ) internal pure returns (uint256) \{\par
        unchecked \{\par
            require(b > 0, errorMessage);\par
            return a / b;\par
        \}\par
    \}\par
\par
    /**\par
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\par
     * reverting with custom message when dividing by zero.\par
     *\par
     * CAUTION: This function is deprecated because it requires allocating memory for the error\par
     * message unnecessarily. For custom revert reasons use \{tryMod\}.\par
     *\par
     * Counterpart to Solidity's `%` operator. This function uses a `revert`\par
     * opcode (which leaves remaining gas untouched) while Solidity uses an\par
     * invalid opcode to revert (consuming all remaining gas).\par
     *\par
     * Requirements:\par
     *\par
     * - The divisor cannot be zero.\par
     */\par
    function mod(\par
        uint256 a,\par
        uint256 b,\par
        string memory errorMessage\par
    ) internal pure returns (uint256) \{\par
        unchecked \{\par
            require(b > 0, errorMessage);\par
            return a % b;\par
        \}\par
    \}\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts/proxy/Clones.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
/**\par
 * @dev {{\field{\*\fldinst{HYPERLINK https://eips.ethereum.org/EIPS/eip-1167[EIP }}{\fldrslt{https://eips.ethereum.org/EIPS/eip-1167[EIP\ul0\cf0}}}}\f0\fs22  1167] is a standard for\par
 * deploying minimal proxy contracts, also known as "clones".\par
 *\par
 * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\par
 * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\par
 *\par
 * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\par
 * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\par
 * deterministic method.\par
 *\par
 * _Available since v3.4._\par
 */\par
library Clones \{\par
    /**\par
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\par
     *\par
     * This function uses the create opcode, which should never revert.\par
     */\par
    function clone(address implementation) internal returns (address instance) \{\par
        assembly \{\par
            let ptr := mload(0x40)\par
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\par
            mstore(add(ptr, 0x14), shl(0x60, implementation))\par
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\par
            instance := create(0, ptr, 0x37)\par
        \}\par
        require(instance != address(0), "ERC1167: create failed");\par
    \}\par
\par
    /**\par
     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\par
     *\par
     * This function uses the create2 opcode and a `salt` to deterministically deploy\par
     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\par
     * the clones cannot be deployed twice at the same address.\par
     */\par
    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) \{\par
        assembly \{\par
            let ptr := mload(0x40)\par
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\par
            mstore(add(ptr, 0x14), shl(0x60, implementation))\par
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\par
            instance := create2(0, ptr, 0x37, salt)\par
        \}\par
        require(instance != address(0), "ERC1167: create2 failed");\par
    \}\par
\par
    /**\par
     * @dev Computes the address of a clone deployed using \{Clones-cloneDeterministic\}.\par
     */\par
    function predictDeterministicAddress(\par
        address implementation,\par
        bytes32 salt,\par
        address deployer\par
    ) internal pure returns (address predicted) \{\par
        assembly \{\par
            let ptr := mload(0x40)\par
            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\par
            mstore(add(ptr, 0x14), shl(0x60, implementation))\par
            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\par
            mstore(add(ptr, 0x38), shl(0x60, deployer))\par
            mstore(add(ptr, 0x4c), salt)\par
            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\par
            predicted := keccak256(add(ptr, 0x37), 0x55)\par
        \}\par
    \}\par
\par
    /**\par
     * @dev Computes the address of a clone deployed using \{Clones-cloneDeterministic\}.\par
     */\par
    function predictDeterministicAddress(address implementation, bytes32 salt)\par
        internal\par
        view\par
        returns (address predicted)\par
    \{\par
        return predictDeterministicAddress(implementation, salt, address(this));\par
    \}\par
\}\par
\par
\par
// Dependency file: contracts/interfaces/IUniswapV2Factory.sol\par
\par
// pragma solidity >=0.5.0;\par
\par
interface IUniswapV2Factory \{\par
    event PairCreated(\par
        address indexed token0,\par
        address indexed token1,\par
        address pair,\par
        uint256\par
    );\par
\par
    function feeTo() external view returns (address);\par
\par
    function feeToSetter() external view returns (address);\par
\par
    function getPair(address tokenA, address tokenB)\par
        external\par
        view\par
        returns (address pair);\par
\par
    function allPairs(uint256) external view returns (address pair);\par
\par
    function allPairsLength() external view returns (uint256);\par
\par
    function createPair(address tokenA, address tokenB)\par
        external\par
        returns (address pair);\par
\par
    function setFeeTo(address) external;\par
\par
    function setFeeToSetter(address) external;\par
\}\par
\par
\par
// Dependency file: contracts/interfaces/IUniswapV2Router02.sol\par
\par
// pragma solidity >=0.6.2;\par
\par
interface IUniswapV2Router01 \{\par
    function factory() external pure returns (address);\par
\par
    function WETH() external pure returns (address);\par
\par
    function addLiquidity(\par
        address tokenA,\par
        address tokenB,\par
        uint256 amountADesired,\par
        uint256 amountBDesired,\par
        uint256 amountAMin,\par
        uint256 amountBMin,\par
        address to,\par
        uint256 deadline\par
    )\par
        external\par
        returns (\par
            uint256 amountA,\par
            uint256 amountB,\par
            uint256 liquidity\par
        );\par
\par
    function addLiquidityETH(\par
        address token,\par
        uint256 amountTokenDesired,\par
        uint256 amountTokenMin,\par
        uint256 amountETHMin,\par
        address to,\par
        uint256 deadline\par
    )\par
        external\par
        payable\par
        returns (\par
            uint256 amountToken,\par
            uint256 amountETH,\par
            uint256 liquidity\par
        );\par
\par
    function removeLiquidity(\par
        address tokenA,\par
        address tokenB,\par
        uint256 liquidity,\par
        uint256 amountAMin,\par
        uint256 amountBMin,\par
        address to,\par
        uint256 deadline\par
    ) external returns (uint256 amountA, uint256 amountB);\par
\par
    function removeLiquidityETH(\par
        address token,\par
        uint256 liquidity,\par
        uint256 amountTokenMin,\par
        uint256 amountETHMin,\par
        address to,\par
        uint256 deadline\par
    ) external returns (uint256 amountToken, uint256 amountETH);\par
\par
    function removeLiquidityWithPermit(\par
        address tokenA,\par
        address tokenB,\par
        uint256 liquidity,\par
        uint256 amountAMin,\par
        uint256 amountBMin,\par
        address to,\par
        uint256 deadline,\par
        bool approveMax,\par
        uint8 v,\par
        bytes32 r,\par
        bytes32 s\par
    ) external returns (uint256 amountA, uint256 amountB);\par
\par
    function removeLiquidityETHWithPermit(\par
        address token,\par
        uint256 liquidity,\par
        uint256 amountTokenMin,\par
        uint256 amountETHMin,\par
        address to,\par
        uint256 deadline,\par
        bool approveMax,\par
        uint8 v,\par
        bytes32 r,\par
        bytes32 s\par
    ) external returns (uint256 amountToken, uint256 amountETH);\par
\par
    function swapExactTokensForTokens(\par
        uint256 amountIn,\par
        uint256 amountOutMin,\par
        address[] calldata path,\par
        address to,\par
        uint256 deadline\par
    ) external returns (uint256[] memory amounts);\par
\par
    function swapTokensForExactTokens(\par
        uint256 amountOut,\par
        uint256 amountInMax,\par
        address[] calldata path,\par
        address to,\par
        uint256 deadline\par
    ) external returns (uint256[] memory amounts);\par
\par
    function swapExactETHForTokens(\par
        uint256 amountOutMin,\par
        address[] calldata path,\par
        address to,\par
        uint256 deadline\par
    ) external payable returns (uint256[] memory amounts);\par
\par
    function swapTokensForExactETH(\par
        uint256 amountOut,\par
        uint256 amountInMax,\par
        address[] calldata path,\par
        address to,\par
        uint256 deadline\par
    ) external returns (uint256[] memory amounts);\par
\par
    function swapExactTokensForETH(\par
        uint256 amountIn,\par
        uint256 amountOutMin,\par
        address[] calldata path,\par
        address to,\par
        uint256 deadline\par
    ) external returns (uint256[] memory amounts);\par
\par
    function swapETHForExactTokens(\par
        uint256 amountOut,\par
        address[] calldata path,\par
        address to,\par
        uint256 deadline\par
    ) external payable returns (uint256[] memory amounts);\par
\par
    function quote(\par
        uint256 amountA,\par
        uint256 reserveA,\par
        uint256 reserveB\par
    ) external pure returns (uint256 amountB);\par
\par
    function getAmountOut(\par
        uint256 amountIn,\par
        uint256 reserveIn,\par
        uint256 reserveOut\par
    ) external pure returns (uint256 amountOut);\par
\par
    function getAmountIn(\par
        uint256 amountOut,\par
        uint256 reserveIn,\par
        uint256 reserveOut\par
    ) external pure returns (uint256 amountIn);\par
\par
    function getAmountsOut(uint256 amountIn, address[] calldata path)\par
        external\par
        view\par
        returns (uint256[] memory amounts);\par
\par
    function getAmountsIn(uint256 amountOut, address[] calldata path)\par
        external\par
        view\par
        returns (uint256[] memory amounts);\par
\}\par
\par
interface IUniswapV2Router02 is IUniswapV2Router01 \{\par
    function removeLiquidityETHSupportingFeeOnTransferTokens(\par
        address token,\par
        uint256 liquidity,\par
        uint256 amountTokenMin,\par
        uint256 amountETHMin,\par
        address to,\par
        uint256 deadline\par
    ) external returns (uint256 amountETH);\par
\par
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\par
        address token,\par
        uint256 liquidity,\par
        uint256 amountTokenMin,\par
        uint256 amountETHMin,\par
        address to,\par
        uint256 deadline,\par
        bool approveMax,\par
        uint8 v,\par
        bytes32 r,\par
        bytes32 s\par
    ) external returns (uint256 amountETH);\par
\par
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\par
        uint256 amountIn,\par
        uint256 amountOutMin,\par
        address[] calldata path,\par
        address to,\par
        uint256 deadline\par
    ) external;\par
\par
    function swapExactETHForTokensSupportingFeeOnTransferTokens(\par
        uint256 amountOutMin,\par
        address[] calldata path,\par
        address to,\par
        uint256 deadline\par
    ) external payable;\par
\par
    function swapExactTokensForETHSupportingFeeOnTransferTokens(\par
        uint256 amountIn,\par
        uint256 amountOutMin,\par
        address[] calldata path,\par
        address to,\par
        uint256 deadline\par
    ) external;\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
/**\par
 * @dev Interface of the ERC20 standard as defined in the EIP.\par
 */\par
interface IERC20Upgradeable \{\par
    /**\par
     * @dev Returns the amount of tokens in existence.\par
     */\par
    function totalSupply() external view returns (uint256);\par
\par
    /**\par
     * @dev Returns the amount of tokens owned by `account`.\par
     */\par
    function balanceOf(address account) external view returns (uint256);\par
\par
    /**\par
     * @dev Moves `amount` tokens from the caller's account to `recipient`.\par
     *\par
     * Returns a boolean value indicating whether the operation succeeded.\par
     *\par
     * Emits a \{Transfer\} event.\par
     */\par
    function transfer(address recipient, uint256 amount) external returns (bool);\par
\par
    /**\par
     * @dev Returns the remaining number of tokens that `spender` will be\par
     * allowed to spend on behalf of `owner` through \{transferFrom\}. This is\par
     * zero by default.\par
     *\par
     * This value changes when \{approve\} or \{transferFrom\} are called.\par
     */\par
    function allowance(address owner, address spender) external view returns (uint256);\par
\par
    /**\par
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\par
     *\par
     * Returns a boolean value indicating whether the operation succeeded.\par
     *\par
     * IMPORTANT: Beware that changing an allowance with this method brings the risk\par
     * that someone may use both the old and the new allowance by unfortunate\par
     * transaction ordering. One possible solution to mitigate this race\par
     * condition is to first reduce the spender's allowance to 0 and set the\par
     * desired value afterwards:\par
     * {{\field{\*\fldinst{HYPERLINK https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 }}{\fldrslt{https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\ul0\cf0}}}}\f0\fs22\par
     *\par
     * Emits an \{Approval\} event.\par
     */\par
    function approve(address spender, uint256 amount) external returns (bool);\par
\par
    /**\par
     * @dev Moves `amount` tokens from `sender` to `recipient` using the\par
     * allowance mechanism. `amount` is then deducted from the caller's\par
     * allowance.\par
     *\par
     * Returns a boolean value indicating whether the operation succeeded.\par
     *\par
     * Emits a \{Transfer\} event.\par
     */\par
    function transferFrom(\par
        address sender,\par
        address recipient,\par
        uint256 amount\par
    ) external returns (bool);\par
\par
    /**\par
     * @dev Emitted when `value` tokens are moved from one account (`from`) to\par
     * another (`to`).\par
     *\par
     * Note that `value` may be zero.\par
     */\par
    event Transfer(address indexed from, address indexed to, uint256 value);\par
\par
    /**\par
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\par
     * a call to \{approve\}. `value` is the new allowance.\par
     */\par
    event Approval(address indexed owner, address indexed spender, uint256 value);\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
// import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";\par
\par
/**\par
 * @dev Interface for the optional metadata functions from the ERC20 standard.\par
 *\par
 * _Available since v4.1._\par
 */\par
interface IERC20MetadataUpgradeable is IERC20Upgradeable \{\par
    /**\par
     * @dev Returns the name of the token.\par
     */\par
    function name() external view returns (string memory);\par
\par
    /**\par
     * @dev Returns the symbol of the token.\par
     */\par
    function symbol() external view returns (string memory);\par
\par
    /**\par
     * @dev Returns the decimals places of the token.\par
     */\par
    function decimals() external view returns (uint8);\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
/**\par
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\par
 * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\par
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\par
 * function so it can only be called once. The \{initializer\} modifier provided by this contract will have this effect.\par
 *\par
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\par
 * possible by providing the encoded function call as the `_data` argument to \{ERC1967Proxy-constructor\}.\par
 *\par
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\par
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\par
 */\par
abstract contract Initializable \{\par
    /**\par
     * @dev Indicates that the contract has been initialized.\par
     */\par
    bool private _initialized;\par
\par
    /**\par
     * @dev Indicates that the contract is in the process of being initialized.\par
     */\par
    bool private _initializing;\par
\par
    /**\par
     * @dev Modifier to protect an initializer function from being invoked twice.\par
     */\par
    modifier initializer() \{\par
        require(_initializing || !_initialized, "Initializable: contract is already initialized");\par
\par
        bool isTopLevelCall = !_initializing;\par
        if (isTopLevelCall) \{\par
            _initializing = true;\par
            _initialized = true;\par
        \}\par
\par
        _;\par
\par
        if (isTopLevelCall) \{\par
            _initializing = false;\par
        \}\par
    \}\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
// import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\par
\par
/**\par
 * @dev Provides information about the current execution context, including the\par
 * sender of the transaction and its data. While these are generally available\par
 * via msg.sender and msg.data, they should not be accessed in such a direct\par
 * manner, since when dealing with meta-transactions the account sending and\par
 * paying for execution may not be the actual sender (as far as an application\par
 * is concerned).\par
 *\par
 * This contract is only required for intermediate, library-like contracts.\par
 */\par
abstract contract ContextUpgradeable is Initializable \{\par
    function __Context_init() internal initializer \{\par
        __Context_init_unchained();\par
    \}\par
\par
    function __Context_init_unchained() internal initializer \{\par
    \}\par
    function _msgSender() internal view virtual returns (address) \{\par
        return msg.sender;\par
    \}\par
\par
    function _msgData() internal view virtual returns (bytes calldata) \{\par
        return msg.data;\par
    \}\par
    uint256[50] private __gap;\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
// import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";\par
// import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol";\par
// import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";\par
// import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\par
\par
/**\par
 * @dev Implementation of the \{IERC20\} interface.\par
 *\par
 * This implementation is agnostic to the way tokens are created. This means\par
 * that a supply mechanism has to be added in a derived contract using \{_mint\}.\par
 * For a generic mechanism see \{ERC20PresetMinterPauser\}.\par
 *\par
 * TIP: For a detailed writeup see our guide\par
 * {{\field{\*\fldinst{HYPERLINK https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How }}{\fldrslt{https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\ul0\cf0}}}}\f0\fs22\par
 * to implement supply mechanisms].\par
 *\par
 * We have followed general OpenZeppelin Contracts guidelines: functions revert\par
 * instead returning `false` on failure. This behavior is nonetheless\par
 * conventional and does not conflict with the expectations of ERC20\par
 * applications.\par
 *\par
 * Additionally, an \{Approval\} event is emitted on calls to \{transferFrom\}.\par
 * This allows applications to reconstruct the allowance for all accounts just\par
 * by listening to said events. Other implementations of the EIP may not emit\par
 * these events, as it isn't required by the specification.\par
 *\par
 * Finally, the non-standard \{decreaseAllowance\} and \{increaseAllowance\}\par
 * functions have been added to mitigate the well-known issues around setting\par
 * allowances. See \{IERC20-approve\}.\par
 */\par
contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable \{\par
    mapping(address => uint256) private _balances;\par
\par
    mapping(address => mapping(address => uint256)) private _allowances;\par
\par
    uint256 private _totalSupply;\par
\par
    string private _name;\par
    string private _symbol;\par
\par
    /**\par
     * @dev Sets the values for \{name\} and \{symbol\}.\par
     *\par
     * The default value of \{decimals\} is 18. To select a different value for\par
     * \{decimals\} you should overload it.\par
     *\par
     * All two of these values are immutable: they can only be set once during\par
     * construction.\par
     */\par
    function __ERC20_init(string memory name_, string memory symbol_) internal initializer \{\par
        __Context_init_unchained();\par
        __ERC20_init_unchained(name_, symbol_);\par
    \}\par
\par
    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer \{\par
        _name = name_;\par
        _symbol = symbol_;\par
    \}\par
\par
    /**\par
     * @dev Returns the name of the token.\par
     */\par
    function name() public view virtual override returns (string memory) \{\par
        return _name;\par
    \}\par
\par
    /**\par
     * @dev Returns the symbol of the token, usually a shorter version of the\par
     * name.\par
     */\par
    function symbol() public view virtual override returns (string memory) \{\par
        return _symbol;\par
    \}\par
\par
    /**\par
     * @dev Returns the number of decimals used to get its user representation.\par
     * For example, if `decimals` equals `2`, a balance of `505` tokens should\par
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\par
     *\par
     * Tokens usually opt for a value of 18, imitating the relationship between\par
     * Ether and Wei. This is the value \{ERC20\} uses, unless this function is\par
     * overridden;\par
     *\par
     * NOTE: This information is only used for _display_ purposes: it in\par
     * no way affects any of the arithmetic of the contract, including\par
     * \{IERC20-balanceOf\} and \{IERC20-transfer\}.\par
     */\par
    function decimals() public view virtual override returns (uint8) \{\par
        return 18;\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-totalSupply\}.\par
     */\par
    function totalSupply() public view virtual override returns (uint256) \{\par
        return _totalSupply;\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-balanceOf\}.\par
     */\par
    function balanceOf(address account) public view virtual override returns (uint256) \{\par
        return _balances[account];\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-transfer\}.\par
     *\par
     * Requirements:\par
     *\par
     * - `recipient` cannot be the zero address.\par
     * - the caller must have a balance of at least `amount`.\par
     */\par
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) \{\par
        _transfer(_msgSender(), recipient, amount);\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-allowance\}.\par
     */\par
    function allowance(address owner, address spender) public view virtual override returns (uint256) \{\par
        return _allowances[owner][spender];\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-approve\}.\par
     *\par
     * Requirements:\par
     *\par
     * - `spender` cannot be the zero address.\par
     */\par
    function approve(address spender, uint256 amount) public virtual override returns (bool) \{\par
        _approve(_msgSender(), spender, amount);\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev See \{IERC20-transferFrom\}.\par
     *\par
     * Emits an \{Approval\} event indicating the updated allowance. This is not\par
     * required by the EIP. See the note at the beginning of \{ERC20\}.\par
     *\par
     * Requirements:\par
     *\par
     * - `sender` and `recipient` cannot be the zero address.\par
     * - `sender` must have a balance of at least `amount`.\par
     * - the caller must have allowance for ``sender``'s tokens of at least\par
     * `amount`.\par
     */\par
    function transferFrom(\par
        address sender,\par
        address recipient,\par
        uint256 amount\par
    ) public virtual override returns (bool) \{\par
        _transfer(sender, recipient, amount);\par
\par
        uint256 currentAllowance = _allowances[sender][_msgSender()];\par
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\par
        unchecked \{\par
            _approve(sender, _msgSender(), currentAllowance - amount);\par
        \}\par
\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev Atomically increases the allowance granted to `spender` by the caller.\par
     *\par
     * This is an alternative to \{approve\} that can be used as a mitigation for\par
     * problems described in \{IERC20-approve\}.\par
     *\par
     * Emits an \{Approval\} event indicating the updated allowance.\par
     *\par
     * Requirements:\par
     *\par
     * - `spender` cannot be the zero address.\par
     */\par
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) \{\par
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev Atomically decreases the allowance granted to `spender` by the caller.\par
     *\par
     * This is an alternative to \{approve\} that can be used as a mitigation for\par
     * problems described in \{IERC20-approve\}.\par
     *\par
     * Emits an \{Approval\} event indicating the updated allowance.\par
     *\par
     * Requirements:\par
     *\par
     * - `spender` cannot be the zero address.\par
     * - `spender` must have allowance for the caller of at least\par
     * `subtractedValue`.\par
     */\par
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) \{\par
        uint256 currentAllowance = _allowances[_msgSender()][spender];\par
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\par
        unchecked \{\par
            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\par
        \}\par
\par
        return true;\par
    \}\par
\par
    /**\par
     * @dev Moves `amount` of tokens from `sender` to `recipient`.\par
     *\par
     * This internal function is equivalent to \{transfer\}, and can be used to\par
     * e.g. implement automatic token fees, slashing mechanisms, etc.\par
     *\par
     * Emits a \{Transfer\} event.\par
     *\par
     * Requirements:\par
     *\par
     * - `sender` cannot be the zero address.\par
     * - `recipient` cannot be the zero address.\par
     * - `sender` must have a balance of at least `amount`.\par
     */\par
    function _transfer(\par
        address sender,\par
        address recipient,\par
        uint256 amount\par
    ) internal virtual \{\par
        require(sender != address(0), "ERC20: transfer from the zero address");\par
        require(recipient != address(0), "ERC20: transfer to the zero address");\par
\par
        _beforeTokenTransfer(sender, recipient, amount);\par
\par
        uint256 senderBalance = _balances[sender];\par
        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\par
        unchecked \{\par
            _balances[sender] = senderBalance - amount;\par
        \}\par
        _balances[recipient] += amount;\par
\par
        emit Transfer(sender, recipient, amount);\par
\par
        _afterTokenTransfer(sender, recipient, amount);\par
    \}\par
\par
    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\par
     * the total supply.\par
     *\par
     * Emits a \{Transfer\} event with `from` set to the zero address.\par
     *\par
     * Requirements:\par
     *\par
     * - `account` cannot be the zero address.\par
     */\par
    function _mint(address account, uint256 amount) internal virtual \{\par
        require(account != address(0), "ERC20: mint to the zero address");\par
\par
        _beforeTokenTransfer(address(0), account, amount);\par
\par
        _totalSupply += amount;\par
        _balances[account] += amount;\par
        emit Transfer(address(0), account, amount);\par
\par
        _afterTokenTransfer(address(0), account, amount);\par
    \}\par
\par
    /**\par
     * @dev Destroys `amount` tokens from `account`, reducing the\par
     * total supply.\par
     *\par
     * Emits a \{Transfer\} event with `to` set to the zero address.\par
     *\par
     * Requirements:\par
     *\par
     * - `account` cannot be the zero address.\par
     * - `account` must have at least `amount` tokens.\par
     */\par
    function _burn(address account, uint256 amount) internal virtual \{\par
        require(account != address(0), "ERC20: burn from the zero address");\par
\par
        _beforeTokenTransfer(account, address(0), amount);\par
\par
        uint256 accountBalance = _balances[account];\par
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\par
        unchecked \{\par
            _balances[account] = accountBalance - amount;\par
        \}\par
        _totalSupply -= amount;\par
\par
        emit Transfer(account, address(0), amount);\par
\par
        _afterTokenTransfer(account, address(0), amount);\par
    \}\par
\par
    /**\par
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\par
     *\par
     * This internal function is equivalent to `approve`, and can be used to\par
     * e.g. set automatic allowances for certain subsystems, etc.\par
     *\par
     * Emits an \{Approval\} event.\par
     *\par
     * Requirements:\par
     *\par
     * - `owner` cannot be the zero address.\par
     * - `spender` cannot be the zero address.\par
     */\par
    function _approve(\par
        address owner,\par
        address spender,\par
        uint256 amount\par
    ) internal virtual \{\par
        require(owner != address(0), "ERC20: approve from the zero address");\par
        require(spender != address(0), "ERC20: approve to the zero address");\par
\par
        _allowances[owner][spender] = amount;\par
        emit Approval(owner, spender, amount);\par
    \}\par
\par
    /**\par
     * @dev Hook that is called before any transfer of tokens. This includes\par
     * minting and burning.\par
     *\par
     * Calling conditions:\par
     *\par
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\par
     * will be transferred to `to`.\par
     * - when `from` is zero, `amount` tokens will be minted for `to`.\par
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\par
     * - `from` and `to` are never both zero.\par
     *\par
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\par
     */\par
    function _beforeTokenTransfer(\par
        address from,\par
        address to,\par
        uint256 amount\par
    ) internal virtual \{\}\par
\par
    /**\par
     * @dev Hook that is called after any transfer of tokens. This includes\par
     * minting and burning.\par
     *\par
     * Calling conditions:\par
     *\par
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\par
     * has been transferred to `to`.\par
     * - when `from` is zero, `amount` tokens have been minted for `to`.\par
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\par
     * - `from` and `to` are never both zero.\par
     *\par
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\par
     */\par
    function _afterTokenTransfer(\par
        address from,\par
        address to,\par
        uint256 amount\par
    ) internal virtual \{\}\par
    uint256[45] private __gap;\par
\}\par
\par
\par
// Dependency file: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\par
\par
\par
// pragma solidity ^0.8.0;\par
\par
// import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";\par
// import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\par
\par
/**\par
 * @dev Contract module which provides a basic access control mechanism, where\par
 * there is an account (an owner) that can be granted exclusive access to\par
 * specific functions.\par
 *\par
 * By default, the owner account will be the one that deploys the contract. This\par
 * can later be changed with \{transferOwnership\}.\par
 *\par
 * This module is used through inheritance. It will make available the modifier\par
 * `onlyOwner`, which can be applied to your functions to restrict their use to\par
 * the owner.\par
 */\par
abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable \{\par
    address private _owner;\par
\par
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\par
\par
    /**\par
     * @dev Initializes the contract setting the deployer as the initial owner.\par
     */\par
    function __Ownable_init() internal initializer \{\par
        __Context_init_unchained();\par
        __Ownable_init_unchained();\par
    \}\par
\par
    function __Ownable_init_unchained() internal initializer \{\par
        _setOwner(_msgSender());\par
    \}\par
\par
    /**\par
     * @dev Returns the address of the current owner.\par
     */\par
    function owner() public view virtual returns (address) \{\par
        return _owner;\par
    \}\par
\par
    /**\par
     * @dev Throws if called by any account other than the owner.\par
     */\par
    modifier onlyOwner() \{\par
        require(owner() == _msgSender(), "Ownable: caller is not the owner");\par
        _;\par
    \}\par
\par
    /**\par
     * @dev Leaves the contract without owner. It will not be possible to call\par
     * `onlyOwner` functions anymore. Can only be called by the current owner.\par
     *\par
     * NOTE: Renouncing ownership will leave the contract without an owner,\par
     * thereby removing any functionality that is only available to the owner.\par
     */\par
    function renounceOwnership() public virtual onlyOwner \{\par
        _setOwner(address(0));\par
    \}\par
\par
    /**\par
     * @dev Transfers ownership of the contract to a new account (`newOwner`).\par
     * Can only be called by the current owner.\par
     */\par
    function transferOwnership(address newOwner) public virtual onlyOwner \{\par
        require(newOwner != address(0), "Ownable: new owner is the zero address");\par
        _setOwner(newOwner);\par
    \}\par
\par
    function _setOwner(address newOwner) private \{\par
        address oldOwner = _owner;\par
        _owner = newOwner;\par
        emit OwnershipTransferred(oldOwner, newOwner);\par
    \}\par
    uint256[49] private __gap;\par
\}\par
\par
\par
// Dependency file: contracts/interfaces/IUniswapV2Pair.sol\par
\par
// pragma solidity >=0.5.0;\par
\par
interface IUniswapV2Pair \{\par
    event Approval(address indexed owner, address indexed spender, uint value);\par
    event Transfer(address indexed from, address indexed to, uint value);\par
\par
    function name() external pure returns (string memory);\par
    function symbol() external pure returns (string memory);\par
    function decimals() external pure returns (uint8);\par
    function totalSupply() external view returns (uint);\par
    function balanceOf(address owner) external view returns (uint);\par
    function allowance(address owner, address spender) external view returns (uint);\par
\par
    function approve(address spender, uint value) external returns (bool);\par
    function transfer(address to, uint value) external returns (bool);\par
    function transferFrom(address from, address to, uint value) external returns (bool);\par
\par
    function DOMAIN_SEPARATOR() external view returns (bytes32);\par
    function PERMIT_TYPEHASH() external pure returns (bytes32);\par
    function nonces(address owner) external view returns (uint);\par
\par
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\par
\par
    event Mint(address indexed sender, uint amount0, uint amount1);\par
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\par
    event Swap(\par
        address indexed sender,\par
        uint amount0In,\par
        uint amount1In,\par
        uint amount0Out,\par
        uint amount1Out,\par
        address indexed to\par
    );\par
    event Sync(uint112 reserve0, uint112 reserve1);\par
\par
    function MINIMUM_LIQUIDITY() external pure returns (uint);\par
    function factory() external view returns (address);\par
    function token0() external view returns (address);\par
    function token1() external view returns (address);\par
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\par
    function price0CumulativeLast() external view returns (uint);\par
    function price1CumulativeLast() external view returns (uint);\par
    function kLast() external view returns (uint);\par
\par
    function mint(address to) external returns (uint liquidity);\par
    function burn(address to) external returns (uint amount0, uint amount1);\par
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\par
    function skim(address to) external;\par
    function sync() external;\par
\par
    function initialize(address, address) external;\par
\}\par
\par
// Dependency file: contracts/libs/SafeMathInt.sol\par
\par
// pragma solidity =0.8.4;\par
\par
/**\par
 * @title SafeMathInt\par
 * @dev Math operations for int256 with overflow safety checks.\par
 */\par
library SafeMathInt \{\par
    int256 private constant MIN_INT256 = int256(1) << 255;\par
    int256 private constant MAX_INT256 = ~(int256(1) << 255);\par
\par
    /**\par
     * @dev Multiplies two int256 variables and fails on overflow.\par
     */\par
    function mul(int256 a, int256 b) internal pure returns (int256) \{\par
        int256 c = a * b;\par
\par
        // Detect overflow when multiplying MIN_INT256 with -1\par
        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\par
        require((b == 0) || (c / b == a));\par
        return c;\par
    \}\par
\par
    /**\par
     * @dev Division of two int256 variables and fails on overflow.\par
     */\par
    function div(int256 a, int256 b) internal pure returns (int256) \{\par
        // Prevent overflow when dividing MIN_INT256 by -1\par
        require(b != -1 || a != MIN_INT256);\par
\par
        // Solidity already throws when dividing by 0.\par
        return a / b;\par
    \}\par
\par
    /**\par
     * @dev Subtracts two int256 variables and fails on overflow.\par
     */\par
    function sub(int256 a, int256 b) internal pure returns (int256) \{\par
        int256 c = a - b;\par
        require((b >= 0 && c <= a) || (b < 0 && c > a));\par
        return c;\par
    \}\par
\par
    /**\par
     * @dev Adds two int256 variables and fails on overflow.\par
     */\par
    function add(int256 a, int256 b) internal pure returns (int256) \{\par
        int256 c = a + b;\par
        require((b >= 0 && c >= a) || (b < 0 && c < a));\par
        return c;\par
    \}\par
\par
    /**\par
     * @dev Converts to absolute value, and fails on overflow.\par
     */\par
    function abs(int256 a) internal pure returns (int256) \{\par
        require(a != MIN_INT256);\par
        return a < 0 ? -a : a;\par
    \}\par
\par
    function toUint256Safe(int256 a) internal pure returns (uint256) \{\par
        require(a >= 0);\par
        return uint256(a);\par
    \}\par
\}\par
\par
\par
// Dependency file: contracts/libs/SafeMathUint.sol\par
\par
// pragma solidity =0.8.4;\par
\par
/**\par
 * @title SafeMathUint\par
 * @dev Math operations with safety checks that revert on error\par
 */\par
library SafeMathUint \{\par
    function toInt256Safe(uint256 a) internal pure returns (int256) \{\par
        int256 b = int256(a);\par
        require(b >= 0);\par
        return b;\par
    \}\par
\}\par
\par
\par
// Dependency file: contracts/baby/IterableMapping.sol\par
\par
// pragma solidity =0.8.4;\par
\par
library IterableMapping \{\par
    // Iterable mapping from address to uint;\par
    struct Map \{\par
        address[] keys;\par
        mapping(address => uint256) values;\par
        mapping(address => uint256) indexOf;\par
        mapping(address => bool) inserted;\par
    \}\par
\par
    function get(Map storage map, address key) public view returns (uint256) \{\par
        return map.values[key];\par
    \}\par
\par
    function getIndexOfKey(Map storage map, address key)\par
        public\par
        view\par
        returns (int256)\par
    \{\par
        if (!map.inserted[key]) \{\par
            return -1;\par
        \}\par
        return int256(map.indexOf[key]);\par
    \}\par
\par
    function getKeyAtIndex(Map storage map, uint256 index)\par
        public\par
        view\par
        returns (address)\par
    \{\par
        return map.keys[index];\par
    \}\par
\par
    function size(Map storage map) public view returns (uint256) \{\par
        return map.keys.length;\par
    \}\par
\par
    function set(\par
        Map storage map,\par
        address key,\par
        uint256 val\par
    ) public \{\par
        if (map.inserted[key]) \{\par
            map.values[key] = val;\par
        \} else \{\par
            map.inserted[key] = true;\par
            map.values[key] = val;\par
            map.indexOf[key] = map.keys.length;\par
            map.keys.push(key);\par
        \}\par
    \}\par
\par
    function remove(Map storage map, address key) public \{\par
        if (!map.inserted[key]) \{\par
            return;\par
        \}\par
\par
        delete map.inserted[key];\par
        delete map.values[key];\par
\par
        uint256 index = map.indexOf[key];\par
        uint256 lastIndex = map.keys.length - 1;\par
        address lastKey = map.keys[lastIndex];\par
\par
        map.indexOf[lastKey] = index;\par
        delete map.indexOf[key];\par
\par
        map.keys[index] = lastKey;\par
        map.keys.pop();\par
    \}\par
\}\par
\par
\par
// Dependency file: contracts/baby/BabyTokenDividendTracker.sol\par
\par
// pragma solidity =0.8.4;\par
\par
// import "@openzeppelin/contracts/token/ERC20/ERC20.sol";\par
// import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";\par
// import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\par
// import "@openzeppelin/contracts/access/Ownable.sol";\par
// import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";\par
// import "@openzeppelin/contracts/utils/math/SafeMath.sol";\par
// import "contracts/interfaces/IUniswapV2Factory.sol";\par
// import "contracts/interfaces/IUniswapV2Router02.sol";\par
// import "contracts/interfaces/IUniswapV2Pair.sol";\par
// import "contracts/libs/SafeMathInt.sol";\par
// import "contracts/libs/SafeMathUint.sol";\par
// import "contracts/baby/IterableMapping.sol";\par
\par
/// @title Dividend-Paying Token Interface\par
/// @author Roger Wu ({{\field{\*\fldinst{HYPERLINK https://github.com/roger-wu }}{\fldrslt{https://github.com/roger-wu\ul0\cf0}}}}\f0\fs22 )\par
/// @dev An interface for a dividend-paying token contract.\par
interface DividendPayingTokenInterface \{\par
    /// @notice View the amount of dividend in wei that an address can withdraw.\par
    /// @param _owner The address of a token holder.\par
    /// @return The amount of dividend in wei that `_owner` can withdraw.\par
    function dividendOf(address _owner) external view returns (uint256);\par
\par
    /// @notice Withdraws the ether distributed to the sender.\par
    /// @dev SHOULD transfer `dividendOf(msg.sender)` wei to `msg.sender`, and `dividendOf(msg.sender)` SHOULD be 0 after the transfer.\par
    ///  MUST emit a `DividendWithdrawn` event if the amount of ether transferred is greater than 0.\par
    function withdrawDividend() external;\par
\par
    /// @dev This event MUST emit when ether is distributed to token holders.\par
    /// @param from The address which sends ether to this contract.\par
    /// @param weiAmount The amount of distributed ether in wei.\par
    event DividendsDistributed(address indexed from, uint256 weiAmount);\par
\par
    /// @dev This event MUST emit when an address withdraws their dividend.\par
    /// @param to The address which withdraws ether from this contract.\par
    /// @param weiAmount The amount of withdrawn ether in wei.\par
    event DividendWithdrawn(address indexed to, uint256 weiAmount);\par
\}\par
\par
/// @title Dividend-Paying Token Optional Interface\par
/// @author Roger Wu ({{\field{\*\fldinst{HYPERLINK https://github.com/roger-wu }}{\fldrslt{https://github.com/roger-wu\ul0\cf0}}}}\f0\fs22 )\par
/// @dev OPTIONAL functions for a dividend-paying token contract.\par
interface DividendPayingTokenOptionalInterface \{\par
    /// @notice View the amount of dividend in wei that an address can withdraw.\par
    /// @param _owner The address of a token holder.\par
    /// @return The amount of dividend in wei that `_owner` can withdraw.\par
    function withdrawableDividendOf(address _owner)\par
        external\par
        view\par
        returns (uint256);\par
\par
    /// @notice View the amount of dividend in wei that an address has withdrawn.\par
    /// @param _owner The address of a token holder.\par
    /// @return The amount of dividend in wei that `_owner` has withdrawn.\par
    function withdrawnDividendOf(address _owner)\par
        external\par
        view\par
        returns (uint256);\par
\par
    /// @notice View the amount of dividend in wei that an address has earned in total.\par
    /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\par
    /// @param _owner The address of a token holder.\par
    /// @return The amount of dividend in wei that `_owner` has earned in total.\par
    function accumulativeDividendOf(address _owner)\par
        external\par
        view\par
        returns (uint256);\par
\}\par
\par
/// @title Dividend-Paying Token\par
/// @author Roger Wu ({{\field{\*\fldinst{HYPERLINK https://github.com/roger-wu }}{\fldrslt{https://github.com/roger-wu\ul0\cf0}}}}\f0\fs22 )\par
/// @dev A mintable ERC20 token that allows anyone to pay and distribute ether\par
///  to token holders as dividends and allows token holders to withdraw their dividends.\par
///  Reference: the source code of PoWH3D: {{\field{\*\fldinst{HYPERLINK https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code }}{\fldrslt{https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\ul0\cf0}}}}\f0\fs22\par
contract DividendPayingToken is\par
    ERC20Upgradeable,\par
    OwnableUpgradeable,\par
    DividendPayingTokenInterface,\par
    DividendPayingTokenOptionalInterface\par
\{\par
    using SafeMath for uint256;\par
    using SafeMathUint for uint256;\par
    using SafeMathInt for int256;\par
\par
    address public rewardToken;\par
\par
    // With `magnitude`, we can properly distribute dividends even if the amount of received ether is small.\par
    // For more discussion about choosing the value of `magnitude`,\par
    //  see {{\field{\*\fldinst{HYPERLINK https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728 }}{\fldrslt{https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\ul0\cf0}}}}\f0\fs22\par
    uint256 internal constant magnitude = 2**128;\par
\par
    uint256 internal magnifiedDividendPerShare;\par
\par
    // About dividendCorrection:\par
    // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\par
    //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\par
    // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\par
    //   `dividendOf(_user)` should not be changed,\par
    //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\par
    // To keep the `dividendOf(_user)` unchanged, we add a correction term:\par
    //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\par
    //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\par
    //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\par
    // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\par
    mapping(address => int256) internal magnifiedDividendCorrections;\par
    mapping(address => uint256) internal withdrawnDividends;\par
\par
    uint256 public totalDividendsDistributed;\par
\par
    function __DividendPayingToken_init(\par
        address _rewardToken,\par
        string memory _name,\par
        string memory _symbol\par
    ) internal initializer \{\par
        __Ownable_init();\par
        __ERC20_init(_name, _symbol);\par
        rewardToken = _rewardToken;\par
    \}\par
\par
    function distributeCAKEDividends(uint256 amount) public onlyOwner \{\par
        require(totalSupply() > 0);\par
\par
        if (amount > 0) \{\par
            magnifiedDividendPerShare = magnifiedDividendPerShare.add(\par
                (amount).mul(magnitude) / totalSupply()\par
            );\par
            emit DividendsDistributed(msg.sender, amount);\par
\par
            totalDividendsDistributed = totalDividendsDistributed.add(amount);\par
        \}\par
    \}\par
\par
    /// @notice Withdraws the ether distributed to the sender.\par
    /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\par
    function withdrawDividend() public virtual override \{\par
        _withdrawDividendOfUser(payable(msg.sender));\par
    \}\par
\par
    /// @notice Withdraws the ether distributed to the sender.\par
    /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\par
    function _withdrawDividendOfUser(address payable user)\par
        internal\par
        returns (uint256)\par
    \{\par
        uint256 _withdrawableDividend = withdrawableDividendOf(user);\par
        if (_withdrawableDividend > 0) \{\par
            withdrawnDividends[user] = withdrawnDividends[user].add(\par
                _withdrawableDividend\par
            );\par
            emit DividendWithdrawn(user, _withdrawableDividend);\par
            bool success = IERC20(rewardToken).transfer(\par
                user,\par
                _withdrawableDividend\par
            );\par
\par
            if (!success) \{\par
                withdrawnDividends[user] = withdrawnDividends[user].sub(\par
                    _withdrawableDividend\par
                );\par
                return 0;\par
            \}\par
\par
            return _withdrawableDividend;\par
        \}\par
\par
        return 0;\par
    \}\par
\par
    /// @notice View the amount of dividend in wei that an address can withdraw.\par
    /// @param _owner The address of a token holder.\par
    /// @return The amount of dividend in wei that `_owner` can withdraw.\par
    function dividendOf(address _owner) public view override returns (uint256) \{\par
        return withdrawableDividendOf(_owner);\par
    \}\par
\par
    /// @notice View the amount of dividend in wei that an address can withdraw.\par
    /// @param _owner The address of a token holder.\par
    /// @return The amount of dividend in wei that `_owner` can withdraw.\par
    function withdrawableDividendOf(address _owner)\par
        public\par
        view\par
        override\par
        returns (uint256)\par
    \{\par
        return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\par
    \}\par
\par
    /// @notice View the amount of dividend in wei that an address has withdrawn.\par
    /// @param _owner The address of a token holder.\par
    /// @return The amount of dividend in wei that `_owner` has withdrawn.\par
    function withdrawnDividendOf(address _owner)\par
        public\par
        view\par
        override\par
        returns (uint256)\par
    \{\par
        return withdrawnDividends[_owner];\par
    \}\par
\par
    /// @notice View the amount of dividend in wei that an address has earned in total.\par
    /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\par
    /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude\par
    /// @param _owner The address of a token holder.\par
    /// @return The amount of dividend in wei that `_owner` has earned in total.\par
    function accumulativeDividendOf(address _owner)\par
        public\par
        view\par
        override\par
        returns (uint256)\par
    \{\par
        return\par
            magnifiedDividendPerShare\par
                .mul(balanceOf(_owner))\par
                .toInt256Safe()\par
                .add(magnifiedDividendCorrections[_owner])\par
                .toUint256Safe() / magnitude;\par
    \}\par
\par
    /// @dev Internal function that transfer tokens from one address to another.\par
    /// Update magnifiedDividendCorrections to keep dividends unchanged.\par
    /// @param from The address to transfer from.\par
    /// @param to The address to transfer to.\par
    /// @param value The amount to be transferred.\par
    function _transfer(\par
        address from,\par
        address to,\par
        uint256 value\par
    ) internal virtual override \{\par
        require(false);\par
\par
        int256 _magCorrection = magnifiedDividendPerShare\par
            .mul(value)\par
            .toInt256Safe();\par
        magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from]\par
            .add(_magCorrection);\par
        magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(\par
            _magCorrection\par
        );\par
    \}\par
\par
    /// @dev Internal function that mints tokens to an account.\par
    /// Update magnifiedDividendCorrections to keep dividends unchanged.\par
    /// @param account The account that will receive the created tokens.\par
    /// @param value The amount that will be created.\par
    function _mint(address account, uint256 value) internal override \{\par
        super._mint(account, value);\par
\par
        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[\par
            account\par
        ].sub((magnifiedDividendPerShare.mul(value)).toInt256Safe());\par
    \}\par
\par
    /// @dev Internal function that burns an amount of the token of a given account.\par
    /// Update magnifiedDividendCorrections to keep dividends unchanged.\par
    /// @param account The account whose tokens will be burnt.\par
    /// @param value The amount that will be burnt.\par
    function _burn(address account, uint256 value) internal override \{\par
        super._burn(account, value);\par
\par
        magnifiedDividendCorrections[account] = magnifiedDividendCorrections[\par
            account\par
        ].add((magnifiedDividendPerShare.mul(value)).toInt256Safe());\par
    \}\par
\par
    function _setBalance(address account, uint256 newBalance) internal \{\par
        uint256 currentBalance = balanceOf(account);\par
\par
        if (newBalance > currentBalance) \{\par
            uint256 mintAmount = newBalance.sub(currentBalance);\par
            _mint(account, mintAmount);\par
        \} else if (newBalance < currentBalance) \{\par
            uint256 burnAmount = currentBalance.sub(newBalance);\par
            _burn(account, burnAmount);\par
        \}\par
    \}\par
\}\par
\par
contract BABYTOKENDividendTracker is OwnableUpgradeable, DividendPayingToken \{\par
    using SafeMath for uint256;\par
    using SafeMathInt for int256;\par
    using IterableMapping for IterableMapping.Map;\par
\par
    IterableMapping.Map private tokenHoldersMap;\par
    uint256 public lastProcessedIndex;\par
\par
    mapping(address => bool) public excludedFromDividends;\par
\par
    mapping(address => uint256) public lastClaimTimes;\par
\par
    uint256 public claimWait;\par
    uint256 public minimumTokenBalanceForDividends;\par
\par
    event ExcludeFromDividends(address indexed account);\par
    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\par
\par
    event Claim(\par
        address indexed account,\par
        uint256 amount,\par
        bool indexed automatic\par
    );\par
\par
    function initialize(\par
        address rewardToken_,\par
        uint256 minimumTokenBalanceForDividends_\par
    ) external initializer \{\par
        DividendPayingToken.__DividendPayingToken_init(\par
            rewardToken_,\par
            "DIVIDEND_TRACKER",\par
            "DIVIDEND_TRACKER"\par
        );\par
        claimWait = 3600;\par
        minimumTokenBalanceForDividends = minimumTokenBalanceForDividends_;\par
    \}\par
\par
    function _transfer(\par
        address,\par
        address,\par
        uint256\par
    ) internal pure override \{\par
        require(false, "Dividend_Tracker: No transfers allowed");\par
    \}\par
\par
    function withdrawDividend() public pure override \{\par
        require(\par
            false,\par
            "Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main BABYTOKEN contract."\par
        );\par
    \}\par
\par
    function excludeFromDividends(address account) external onlyOwner \{\par
        require(!excludedFromDividends[account]);\par
        excludedFromDividends[account] = true;\par
\par
        _setBalance(account, 0);\par
        tokenHoldersMap.remove(account);\par
\par
        emit ExcludeFromDividends(account);\par
    \}\par
\par
    function isExcludedFromDividends(address account)\par
        public\par
        view\par
        returns (bool)\par
    \{\par
        return excludedFromDividends[account];\par
    \}\par
\par
    function updateClaimWait(uint256 newClaimWait) external onlyOwner \{\par
        require(\par
            newClaimWait >= 3600 && newClaimWait <= 86400,\par
            "Dividend_Tracker: claimWait must be updated to between 1 and 24 hours"\par
        );\par
        require(\par
            newClaimWait != claimWait,\par
            "Dividend_Tracker: Cannot update claimWait to same value"\par
        );\par
        emit ClaimWaitUpdated(newClaimWait, claimWait);\par
        claimWait = newClaimWait;\par
    \}\par
\par
    function updateMinimumTokenBalanceForDividends(uint256 amount)\par
        external\par
        onlyOwner\par
    \{\par
        minimumTokenBalanceForDividends = amount;\par
    \}\par
\par
    function getLastProcessedIndex() external view returns (uint256) \{\par
        return lastProcessedIndex;\par
    \}\par
\par
    function getNumberOfTokenHolders() external view returns (uint256) \{\par
        return tokenHoldersMap.keys.length;\par
    \}\par
\par
    function getAccount(address _account)\par
        public\par
        view\par
        returns (\par
            address account,\par
            int256 index,\par
            int256 iterationsUntilProcessed,\par
            uint256 withdrawableDividends,\par
            uint256 totalDividends,\par
            uint256 lastClaimTime,\par
            uint256 nextClaimTime,\par
            uint256 secondsUntilAutoClaimAvailable\par
        )\par
    \{\par
        account = _account;\par
\par
        index = tokenHoldersMap.getIndexOfKey(account);\par
\par
        iterationsUntilProcessed = -1;\par
\par
        if (index >= 0) \{\par
            if (uint256(index) > lastProcessedIndex) \{\par
                iterationsUntilProcessed = index.sub(\par
                    int256(lastProcessedIndex)\par
                );\par
            \} else \{\par
                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length >\par
                    lastProcessedIndex\par
                    ? tokenHoldersMap.keys.length.sub(lastProcessedIndex)\par
                    : 0;\par
\par
                iterationsUntilProcessed = index.add(\par
                    int256(processesUntilEndOfArray)\par
                );\par
            \}\par
        \}\par
\par
        withdrawableDividends = withdrawableDividendOf(account);\par
        totalDividends = accumulativeDividendOf(account);\par
\par
        lastClaimTime = lastClaimTimes[account];\par
\par
        nextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(claimWait) : 0;\par
\par
        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp\par
            ? nextClaimTime.sub(block.timestamp)\par
            : 0;\par
    \}\par
\par
    function getAccountAtIndex(uint256 index)\par
        public\par
        view\par
        returns (\par
            address,\par
            int256,\par
            int256,\par
            uint256,\par
            uint256,\par
            uint256,\par
            uint256,\par
            uint256\par
        )\par
    \{\par
        if (index >= tokenHoldersMap.size()) \{\par
            return (address(0), -1, -1, 0, 0, 0, 0, 0);\par
        \}\par
\par
        address account = tokenHoldersMap.getKeyAtIndex(index);\par
\par
        return getAccount(account);\par
    \}\par
\par
    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) \{\par
        if (lastClaimTime > block.timestamp) \{\par
            return false;\par
        \}\par
\par
        return block.timestamp.sub(lastClaimTime) >= claimWait;\par
    \}\par
\par
    function setBalance(address payable account, uint256 newBalance)\par
        external\par
        onlyOwner\par
    \{\par
        if (excludedFromDividends[account]) \{\par
            return;\par
        \}\par
        if (newBalance >= minimumTokenBalanceForDividends) \{\par
            _setBalance(account, newBalance);\par
            tokenHoldersMap.set(account, newBalance);\par
        \} else \{\par
            _setBalance(account, 0);\par
            tokenHoldersMap.remove(account);\par
        \}\par
        processAccount(account, true);\par
    \}\par
\par
    function process(uint256 gas)\par
        public\par
        returns (\par
            uint256,\par
            uint256,\par
            uint256\par
        )\par
    \{\par
        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\par
\par
        if (numberOfTokenHolders == 0) \{\par
            return (0, 0, lastProcessedIndex);\par
        \}\par
\par
        uint256 _lastProcessedIndex = lastProcessedIndex;\par
\par
        uint256 gasUsed = 0;\par
\par
        uint256 gasLeft = gasleft();\par
\par
        uint256 iterations = 0;\par
        uint256 claims = 0;\par
\par
        while (gasUsed < gas && iterations < numberOfTokenHolders) \{\par
            _lastProcessedIndex++;\par
\par
            if (_lastProcessedIndex >= tokenHoldersMap.keys.length) \{\par
                _lastProcessedIndex = 0;\par
            \}\par
\par
            address account = tokenHoldersMap.keys[_lastProcessedIndex];\par
\par
            if (canAutoClaim(lastClaimTimes[account])) \{\par
                if (processAccount(payable(account), true)) \{\par
                    claims++;\par
                \}\par
            \}\par
\par
            iterations++;\par
\par
            uint256 newGasLeft = gasleft();\par
\par
            if (gasLeft > newGasLeft) \{\par
                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\par
            \}\par
\par
            gasLeft = newGasLeft;\par
        \}\par
\par
        lastProcessedIndex = _lastProcessedIndex;\par
\par
        return (iterations, claims, lastProcessedIndex);\par
    \}\par
\par
    function processAccount(address payable account, bool automatic)\par
        public\par
        onlyOwner\par
        returns (bool)\par
    \{\par
        uint256 amount = _withdrawDividendOfUser(account);\par
\par
        if (amount > 0) \{\par
            lastClaimTimes[account] = block.timestamp;\par
            emit Claim(account, amount, automatic);\par
            return true;\par
        \}\par
\par
        return false;\par
    \}\par
\}\par
\par
\par
// Dependency file: contracts/BaseToken.sol\par
\par
// pragma solidity =0.8.4;\par
\par
enum TokenType \{\par
    standard,\par
    antiBotStandard,\par
    liquidityGenerator,\par
    antiBotLiquidityGenerator,\par
    baby,\par
    antiBotBaby,\par
    buybackBaby,\par
    antiBotBuybackBaby\par
\}\par
\par
abstract contract BaseToken \{\par
    event TokenCreated(\par
        address indexed owner,\par
        address indexed token,\par
        TokenType tokenType,\par
        uint256 version\par
    );\par
\}\par
\par
\par
// Root file: contracts/baby/BabyToken.sol\par
\par
pragma solidity =0.8.4;\par
\par
// import "@openzeppelin/contracts/token/ERC20/ERC20.sol";\par
// import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\par
// import "@openzeppelin/contracts/access/Ownable.sol";\par
// import "@openzeppelin/contracts/utils/math/SafeMath.sol";\par
// import "@openzeppelin/contracts/proxy/Clones.sol";\par
// import "contracts/interfaces/IUniswapV2Factory.sol";\par
// import "contracts/interfaces/IUniswapV2Router02.sol";\par
// import "contracts/baby/BabyTokenDividendTracker.sol";\par
// import "contracts/BaseToken.sol";\par
\par
contract BABYTOKEN is ERC20, Ownable, BaseToken \{\par
    using SafeMath for uint256;\par
\par
    uint256 public constant VERSION = 1;\par
\par
    IUniswapV2Router02 public uniswapV2Router;\par
    address public uniswapV2Pair;\par
\par
    bool private swapping;\par
\par
    BABYTOKENDividendTracker public dividendTracker;\par
\par
    address public rewardToken;\par
\par
    uint256 public swapTokensAtAmount;\par
\par
    uint256 public tokenRewardsFee;\par
    uint256 public liquidityFee;\par
    uint256 public marketingFee;\par
    uint256 public totalFees;\par
\par
    address public _marketingWalletAddress;\par
\par
    uint256 public gasForProcessing;\par
\par
    // exlcude from fees and max transaction amount\par
    mapping(address => bool) private _isExcludedFromFees;\par
\par
    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\par
    // could be subject to a maximum transfer amount\par
    mapping(address => bool) public automatedMarketMakerPairs;\par
\par
    event UpdateDividendTracker(\par
        address indexed newAddress,\par
        address indexed oldAddress\par
    );\par
\par
    event UpdateUniswapV2Router(\par
        address indexed newAddress,\par
        address indexed oldAddress\par
    );\par
\par
    event ExcludeFromFees(address indexed account, bool isExcluded);\par
    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\par
\par
    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\par
\par
    event LiquidityWalletUpdated(\par
        address indexed newLiquidityWallet,\par
        address indexed oldLiquidityWallet\par
    );\par
\par
    event GasForProcessingUpdated(\par
        uint256 indexed newValue,\par
        uint256 indexed oldValue\par
    );\par
\par
    event SwapAndLiquify(\par
        uint256 tokensSwapped,\par
        uint256 ethReceived,\par
        uint256 tokensIntoLiqudity\par
    );\par
\par
    event SendDividends(uint256 tokensSwapped, uint256 amount);\par
\par
    event ProcessedDividendTracker(\par
        uint256 iterations,\par
        uint256 claims,\par
        uint256 lastProcessedIndex,\par
        bool indexed automatic,\par
        uint256 gas,\par
        address indexed processor\par
    );\par
\par
    constructor(\par
        string memory name_,\par
        string memory symbol_,\par
        uint256 totalSupply_,\par
        address[4] memory addrs, // reward, router, marketing wallet, dividendTracker\par
        uint256[3] memory feeSettings, // rewards, liquidity, marketing\par
        uint256 minimumTokenBalanceForDividends_,\par
        address serviceFeeReceiver_,\par
        uint256 serviceFee_\par
    ) payable ERC20(name_, symbol_) \{\par
        rewardToken = addrs[0];\par
        _marketingWalletAddress = addrs[2];\par
        require(\par
            msg.sender != _marketingWalletAddress,\par
            "Owner and marketing wallet cannot be the same"\par
        );\par
\par
        tokenRewardsFee = feeSettings[0];\par
        liquidityFee = feeSettings[1];\par
        marketingFee = feeSettings[2];\par
        totalFees = tokenRewardsFee.add(liquidityFee).add(marketingFee);\par
        require(totalFees <= 25, "Total fee is over 25%");\par
        swapTokensAtAmount = totalSupply_.mul(2).div(10**6); // 0.002%\par
\par
        // use by default 300,000 gas to process auto-claiming dividends\par
        gasForProcessing = 300000;\par
\par
        dividendTracker = BABYTOKENDividendTracker(\par
            payable(Clones.clone(addrs[3]))\par
        );\par
        dividendTracker.initialize(\par
            rewardToken,\par
            minimumTokenBalanceForDividends_\par
        );\par
\par
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(addrs[1]);\par
        // Create a uniswap pair for this new token\par
        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\par
            .createPair(address(this), _uniswapV2Router.WETH());\par
        uniswapV2Router = _uniswapV2Router;\par
        uniswapV2Pair = _uniswapV2Pair;\par
        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\par
\par
        // exclude from receiving dividends\par
        dividendTracker.excludeFromDividends(address(dividendTracker));\par
        dividendTracker.excludeFromDividends(address(this));\par
        dividendTracker.excludeFromDividends(owner());\par
        dividendTracker.excludeFromDividends(address(0xdead));\par
        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\par
        // exclude from paying fees or having max transaction amount\par
        excludeFromFees(owner(), true);\par
        excludeFromFees(_marketingWalletAddress, true);\par
        excludeFromFees(address(this), true);\par
        /*\par
            _mint is an internal function in ERC20.sol that is only called here,\par
            and CANNOT be called ever again\par
        */\par
        _mint(owner(), totalSupply_);\par
\par
        emit TokenCreated(owner(), address(this), TokenType.baby, VERSION);\par
\par
        payable(serviceFeeReceiver_).transfer(serviceFee_);\par
    \}\par
\par
    receive() external payable \{\}\par
\par
    function setSwapTokensAtAmount(uint256 amount) external onlyOwner \{\par
        swapTokensAtAmount = amount;\par
    \}\par
\par
    function updateDividendTracker(address newAddress) public onlyOwner \{\par
        require(\par
            newAddress != address(dividendTracker),\par
            "BABYTOKEN: The dividend tracker already has that address"\par
        );\par
\par
        BABYTOKENDividendTracker newDividendTracker = BABYTOKENDividendTracker(\par
            payable(newAddress)\par
        );\par
\par
        require(\par
            newDividendTracker.owner() == address(this),\par
            "BABYTOKEN: The new dividend tracker must be owned by the BABYTOKEN token contract"\par
        );\par
\par
        newDividendTracker.excludeFromDividends(address(newDividendTracker));\par
        newDividendTracker.excludeFromDividends(address(this));\par
        newDividendTracker.excludeFromDividends(owner());\par
        newDividendTracker.excludeFromDividends(address(uniswapV2Router));\par
\par
        emit UpdateDividendTracker(newAddress, address(dividendTracker));\par
\par
        dividendTracker = newDividendTracker;\par
    \}\par
\par
    function updateUniswapV2Router(address newAddress) public onlyOwner \{\par
        require(\par
            newAddress != address(uniswapV2Router),\par
            "BABYTOKEN: The router already has that address"\par
        );\par
        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\par
        uniswapV2Router = IUniswapV2Router02(newAddress);\par
        address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\par
            .createPair(address(this), uniswapV2Router.WETH());\par
        uniswapV2Pair = _uniswapV2Pair;\par
    \}\par
\par
    function excludeFromFees(address account, bool excluded) public onlyOwner \{\par
        require(\par
            _isExcludedFromFees[account] != excluded,\par
            "BABYTOKEN: Account is already the value of 'excluded'"\par
        );\par
        _isExcludedFromFees[account] = excluded;\par
\par
        emit ExcludeFromFees(account, excluded);\par
    \}\par
\par
    function excludeMultipleAccountsFromFees(\par
        address[] calldata accounts,\par
        bool excluded\par
    ) public onlyOwner \{\par
        for (uint256 i = 0; i < accounts.length; i++) \{\par
            _isExcludedFromFees[accounts[i]] = excluded;\par
        \}\par
\par
        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\par
    \}\par
\par
    function setMarketingWallet(address payable wallet) external onlyOwner \{\par
        _marketingWalletAddress = wallet;\par
    \}\par
\par
    function setTokenRewardsFee(uint256 value) external onlyOwner \{\par
        tokenRewardsFee = value;\par
        totalFees = tokenRewardsFee.add(liquidityFee).add(marketingFee);\par
        require(totalFees <= 25, "Total fee is over 25%");\par
    \}\par
\par
    function setLiquiditFee(uint256 value) external onlyOwner \{\par
        liquidityFee = value;\par
        totalFees = tokenRewardsFee.add(liquidityFee).add(marketingFee);\par
        require(totalFees <= 25, "Total fee is over 25%");\par
    \}\par
\par
    function setMarketingFee(uint256 value) external onlyOwner \{\par
        marketingFee = value;\par
        totalFees = tokenRewardsFee.add(liquidityFee).add(marketingFee);\par
        require(totalFees <= 25, "Total fee is over 25%");\par
    \}\par
\par
    function setAutomatedMarketMakerPair(address pair, bool value)\par
        public\par
        onlyOwner\par
    \{\par
        require(\par
            pair != uniswapV2Pair,\par
            "BABYTOKEN: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs"\par
        );\par
\par
        _setAutomatedMarketMakerPair(pair, value);\par
    \}\par
\par
    function _setAutomatedMarketMakerPair(address pair, bool value) private \{\par
        require(\par
            automatedMarketMakerPairs[pair] != value,\par
            "BABYTOKEN: Automated market maker pair is already set to that value"\par
        );\par
        automatedMarketMakerPairs[pair] = value;\par
\par
        if (value) \{\par
            dividendTracker.excludeFromDividends(pair);\par
        \}\par
\par
        emit SetAutomatedMarketMakerPair(pair, value);\par
    \}\par
\par
    function updateGasForProcessing(uint256 newValue) public onlyOwner \{\par
        require(\par
            newValue >= 200000 && newValue <= 500000,\par
            "BABYTOKEN: gasForProcessing must be between 200,000 and 500,000"\par
        );\par
        require(\par
            newValue != gasForProcessing,\par
            "BABYTOKEN: Cannot update gasForProcessing to same value"\par
        );\par
        emit GasForProcessingUpdated(newValue, gasForProcessing);\par
        gasForProcessing = newValue;\par
    \}\par
\par
    function updateClaimWait(uint256 claimWait) external onlyOwner \{\par
        dividendTracker.updateClaimWait(claimWait);\par
    \}\par
\par
    function getClaimWait() external view returns (uint256) \{\par
        return dividendTracker.claimWait();\par
    \}\par
\par
    function updateMinimumTokenBalanceForDividends(uint256 amount)\par
        external\par
        onlyOwner\par
    \{\par
        dividendTracker.updateMinimumTokenBalanceForDividends(amount);\par
    \}\par
\par
    function getMinimumTokenBalanceForDividends()\par
        external\par
        view\par
        returns (uint256)\par
    \{\par
        return dividendTracker.minimumTokenBalanceForDividends();\par
    \}\par
\par
    function getTotalDividendsDistributed() external view returns (uint256) \{\par
        return dividendTracker.totalDividendsDistributed();\par
    \}\par
\par
    function isExcludedFromFees(address account) public view returns (bool) \{\par
        return _isExcludedFromFees[account];\par
    \}\par
\par
    function withdrawableDividendOf(address account)\par
        public\par
        view\par
        returns (uint256)\par
    \{\par
        return dividendTracker.withdrawableDividendOf(account);\par
    \}\par
\par
    function dividendTokenBalanceOf(address account)\par
        public\par
        view\par
        returns (uint256)\par
    \{\par
        return dividendTracker.balanceOf(account);\par
    \}\par
\par
    function excludeFromDividends(address account) external onlyOwner \{\par
        dividendTracker.excludeFromDividends(account);\par
    \}\par
\par
    function isExcludedFromDividends(address account)\par
        public\par
        view\par
        returns (bool)\par
    \{\par
        return dividendTracker.isExcludedFromDividends(account);\par
    \}\par
\par
    function getAccountDividendsInfo(address account)\par
        external\par
        view\par
        returns (\par
            address,\par
            int256,\par
            int256,\par
            uint256,\par
            uint256,\par
            uint256,\par
            uint256,\par
            uint256\par
        )\par
    \{\par
        return dividendTracker.getAccount(account);\par
    \}\par
\par
    function getAccountDividendsInfoAtIndex(uint256 index)\par
        external\par
        view\par
        returns (\par
            address,\par
            int256,\par
            int256,\par
            uint256,\par
            uint256,\par
            uint256,\par
            uint256,\par
            uint256\par
        )\par
    \{\par
        return dividendTracker.getAccountAtIndex(index);\par
    \}\par
\par
    function processDividendTracker(uint256 gas) external \{\par
        (\par
            uint256 iterations,\par
            uint256 claims,\par
            uint256 lastProcessedIndex\par
        ) = dividendTracker.process(gas);\par
        emit ProcessedDividendTracker(\par
            iterations,\par
            claims,\par
            lastProcessedIndex,\par
            false,\par
            gas,\par
            tx.origin\par
        );\par
    \}\par
\par
    function claim() external \{\par
        dividendTracker.processAccount(payable(msg.sender), false);\par
    \}\par
\par
    function getLastProcessedIndex() external view returns (uint256) \{\par
        return dividendTracker.getLastProcessedIndex();\par
    \}\par
\par
    function getNumberOfDividendTokenHolders() external view returns (uint256) \{\par
        return dividendTracker.getNumberOfTokenHolders();\par
    \}\par
\par
    function _transfer(\par
        address from,\par
        address to,\par
        uint256 amount\par
    ) internal override \{\par
        require(from != address(0), "ERC20: transfer from the zero address");\par
        require(to != address(0), "ERC20: transfer to the zero address");\par
\par
        if (amount == 0) \{\par
            super._transfer(from, to, 0);\par
            return;\par
        \}\par
\par
        uint256 contractTokenBalance = balanceOf(address(this));\par
\par
        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\par
\par
        if (\par
            canSwap &&\par
            !swapping &&\par
            !automatedMarketMakerPairs[from] &&\par
            from != owner() &&\par
            to != owner()\par
        ) \{\par
            swapping = true;\par
\par
            uint256 marketingTokens = contractTokenBalance\par
                .mul(marketingFee)\par
                .div(totalFees);\par
            swapAndSendToFee(marketingTokens);\par
\par
            uint256 swapTokens = contractTokenBalance.mul(liquidityFee).div(\par
                totalFees\par
            );\par
            swapAndLiquify(swapTokens);\par
\par
            uint256 sellTokens = balanceOf(address(this));\par
            swapAndSendDividends(sellTokens);\par
\par
            swapping = false;\par
        \}\par
\par
        bool takeFee = !swapping;\par
\par
        // if any account belongs to _isExcludedFromFee account then remove the fee\par
        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) \{\par
            takeFee = false;\par
        \}\par
\par
        if (takeFee) \{\par
            uint256 fees = amount.mul(totalFees).div(100);\par
            if (automatedMarketMakerPairs[to]) \{\par
                fees += amount.mul(1).div(100);\par
            \}\par
            amount = amount.sub(fees);\par
\par
            super._transfer(from, address(this), fees);\par
        \}\par
\par
        super._transfer(from, to, amount);\par
\par
        try\par
            dividendTracker.setBalance(payable(from), balanceOf(from))\par
        \{\} catch \{\}\par
        try dividendTracker.setBalance(payable(to), balanceOf(to)) \{\} catch \{\}\par
\par
        if (!swapping) \{\par
            uint256 gas = gasForProcessing;\par
\par
            try dividendTracker.process(gas) returns (\par
                uint256 iterations,\par
                uint256 claims,\par
                uint256 lastProcessedIndex\par
            ) \{\par
                emit ProcessedDividendTracker(\par
                    iterations,\par
                    claims,\par
                    lastProcessedIndex,\par
                    true,\par
                    gas,\par
                    tx.origin\par
                );\par
            \} catch \{\}\par
        \}\par
    \}\par
\par
    function swapAndSendToFee(uint256 tokens) private \{\par
        uint256 initialCAKEBalance = IERC20(rewardToken).balanceOf(\par
            address(this)\par
        );\par
\par
        swapTokensForCake(tokens);\par
        uint256 newBalance = (IERC20(rewardToken).balanceOf(address(this))).sub(\par
            initialCAKEBalance\par
        );\par
        IERC20(rewardToken).transfer(_marketingWalletAddress, newBalance);\par
    \}\par
\par
    function swapAndLiquify(uint256 tokens) private \{\par
        // split the contract balance into halves\par
        uint256 half = tokens.div(2);\par
        uint256 otherHalf = tokens.sub(half);\par
\par
        // capture the contract's current ETH balance.\par
        // this is so that we can capture exactly the amount of ETH that the\par
        // swap creates, and not make the liquidity event include any ETH that\par
        // has been manually sent to the contract\par
        uint256 initialBalance = address(this).balance;\par
\par
        // swap tokens for ETH\par
        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\par
\par
        // how much ETH did we just swap into?\par
        uint256 newBalance = address(this).balance.sub(initialBalance);\par
\par
        // add liquidity to uniswap\par
        addLiquidity(otherHalf, newBalance);\par
\par
        emit SwapAndLiquify(half, newBalance, otherHalf);\par
    \}\par
\par
    function swapTokensForEth(uint256 tokenAmount) private \{\par
        // generate the uniswap pair path of token -> weth\par
        address[] memory path = new address[](2);\par
        path[0] = address(this);\par
        path[1] = uniswapV2Router.WETH();\par
\par
        _approve(address(this), address(uniswapV2Router), tokenAmount);\par
\par
        // make the swap\par
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\par
            tokenAmount,\par
            0, // accept any amount of ETH\par
            path,\par
            address(this),\par
            block.timestamp\par
        );\par
    \}\par
\par
    function swapTokensForCake(uint256 tokenAmount) private \{\par
        address[] memory path = new address[](3);\par
        path[0] = address(this);\par
        path[1] = uniswapV2Router.WETH();\par
        path[2] = rewardToken;\par
\par
        _approve(address(this), address(uniswapV2Router), tokenAmount);\par
\par
        // make the swap\par
        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\par
            tokenAmount,\par
            0,\par
            path,\par
            address(this),\par
            block.timestamp\par
        );\par
    \}\par
\par
    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private \{\par
        // approve token transfer to cover all possible scenarios\par
        _approve(address(this), address(uniswapV2Router), tokenAmount);\par
\par
        // add the liquidity\par
        uniswapV2Router.addLiquidityETH\{value: ethAmount\}(\par
            address(this),\par
            tokenAmount,\par
            0, // slippage is unavoidable\par
            0, // slippage is unavoidable\par
            address(0),\par
            block.timestamp\par
        );\par
    \}\par
\par
    function swapAndSendDividends(uint256 tokens) private \{\par
        swapTokensForCake(tokens);\par
        uint256 dividends = IERC20(rewardToken).balanceOf(address(this));\par
        bool success = IERC20(rewardToken).transfer(\par
            address(dividendTracker),\par
            dividends\par
        );\par
\par
        if (success) \{\par
            dividendTracker.distributeCAKEDividends(dividends);\par
            emit SendDividends(tokens, dividends);\par
        \}\par
    \}\par
\}\par
}
 